## 前回のセッションで挙がった課題

【イミュータブルデータモデル】

- イベントをエンティティ（リソース）として扱うことにメリットがあるのか？
    - エンティティの更新を抑制できる
        - 更新には複雑なルールが絡むことが多いので更新はなるべく少なくしたい
    - 履歴をトレースすることができる
        - 例えば会員テーブルに更新日時カラムを設けて、情報変更や強制退会のたびに1レコードに更新をかけたとする
            - そうすると、最終更新された日時や最新の状態はわかるが、過去の情報はトレースできなくなる

【アンチパターン5 課題2】

- 最新の契約情報をNewCustomerに持たせるか？もしくは別のテーブルに持たせるか？をメリットデメリットを洗って考えてみる
    - 契約に複数のイベントが発生する場合は
    
    ```
    同一テーブルに持たせる
    メリット
    - Customerテーブルに対し、customer_idで検索するだけなので、契約状態の取得や更新が容易
    	- イージーではあるが、シンプルではない...
    デメリット
    - 更新が発生する
    - 契約に複数のイベントが発生する場合にそれぞれの状態を管理することが難しい
    
    別テーブルに持たせる
    メリット
    - updateが発生しない
    - 契約、解約、休会など複数のイベントリソースを分けて設計も可能（＝拡張性）
    デメリット
    - 特になし..？
    ```
    
- 解約はどのように表すべきか？
    - 上述の通り、解約というイベントをリソースとして考え、解約テーブルを設ける
        - 顧客テーブルに「契約」「解約」「休会」などのイベントを各テーブルに保存する
    - 理由として、顧客がいつ契約/解約したかはトレースできる状態にすべき状態と判断し、1レコードを更新する形ではなく、別テーブルで格納すべきと思った

【イミュータブルデータモデルを読んでの感想】

[https://scrapbox.io/kawasima/イミュータブルデータモデル](https://scrapbox.io/kawasima/%E3%82%A4%E3%83%9F%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%96%E3%83%AB%E3%83%87%E3%83%BC%E3%82%BF%E3%83%A2%E3%83%87%E3%83%AB)

- CRUDのうち、更新がシステムを複雑にする
    - 理由は、更新は複雑なルールを伴うから
- 業務的には複雑さがあるのはしょうがないが、システムや設計上は複雑さを抑制したい
- 複雑さを抑制するためのデータモデルに該当するのがイミュータブルデータモデルである
- S1. エンティティの抽出
    - 要求文書に対して5W1Hを考える
    - 早すぎる最適化をしないようにする
- S2. エンティティの分類
    - 抽出したエンティティを「リソース」と「イベント」に分類する
    - エンティティに「〜する」を末尾につけることができれば「イベント」である
        - 「注文」は「注文する」で成り立つのでイベントである
- S3. イベント編: イベントエンティティには1つの日時属性しか持たないようにする
    - 日時属性を複数含む＝このエンティティに対して更新が多く発生することを指す
        - つまり、複雑なルールの元、多くのエンティティが更新される
    - 1つの日時属性では足らない場合は「ロングタームイベントパターン」が有用である
        - eg. 入会
- S4. リソースに隠されたイベントを抽出する
    - リソースに更新日時カラムを持たせたいとなったら、そこにはイベントが隠れていることがある
        - eg.会員、会員変更、会員の強制退会など..
    - 全てのテーブルに作成日時や更新日時を設ける場合はそれが何のために必要かを考える
        - トレースするためなら、別テーブルに各世代を格納する必要がある
    - リソースの区分
        - 業務上扱いが変わるものは「サブタイプ」として持つのが良い
            - 社員 — 退職社員 — 現役社員
            - スーパータイプとサブタイプの設計手法はユースケースによって3種類ある
- S5. 非依存リレーションシップを交差エンティティにする
    - 1対多の関係であっても非依存であれば間に交差テーブルをおく
        - eg. 部門 — 所属 — 社員
        - 部門は社員がいなくても存在する / 社員は部門がなくても存在するので非依存
        - こうすることで、配属前にinsertされた社員に対し、配属後にupdateをするという必要がなくなる

[https://www.slideshare.net/kawasima/ss-250716400](https://www.slideshare.net/kawasima/ss-250716400) （スライド版）

- どのイベントを記録して残すか？が業務設計であり、イベント設計である